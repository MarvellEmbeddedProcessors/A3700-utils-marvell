TEST_ADDR_AND_BRANCH: 0xC000D00C 0x80000000 0x00000000 == BPS1
AND_VAL: 0xC000D00C 0x7FFFFFFF
WRITE: 0xC0013840 0x00001D1E
LABEL: BPS0
NOP:
BRANCH: BPS0
LABEL: BPS1

; A3700 IO configuration
; On A3700 DB north bridge VDDO_PIO and VDDO_SIO are 1.8V, VDDO_JIO is 2.5V.
AND_VAL: 0xC0015600 0xFFFFFEFF
OR_VAL: 0xC0015600 0x00000600
; On A3700 DB south bridge GBE core voltage is 2.5V.
OR_VAL: 0xC001A400 0x00000040
;
;************************************************
; A3700 read NB OTP
; Put all OTP data to SM0~SM2, LSB->MSB
; Put SVC_REV to SM3
;************************************************
; 1. Clear OTP_MODE_NB (RD0012600h [15]) = 0
AND_VAL: 0xC0012600 0xFFFF7FFF
;
; 2. Set OTP_POR_B_NB (RD0012600h [13]) = 1
OR_VAL: 0xC0012600 0x00002000
;
; 3. Set OTP_PTR_INC_NB (RD0012608h [8]) = 1.
OR_VAL: 0xC0012608 0x00000100
;
; 4. Set OTP_RPTR_RST_NB (RD0012600h [14]) to 1
; Then write 0 to the same field
OR_VAL: 0xC0012600 0x00004000
;
AND_VAL: 0xC0012600 0xFFFFBFFF
;
; 5. Toggle OTP_PRDT_NB (RD0012600h [3]).
;    a. Set OTP_PRDT_NB (RD0012600h [3]) to 1.
;    b. Clear OTP_PRDT_NB (RD0012600h [3]) to 0.
;    c. Wait for a minimum of 100 ns.
;    d. Set OTP_PRDT_NB (RD0012600h [3]) to 1.
OR_VAL: 0xC0012600 0x00000008
;
AND_VAL: 0xC0012600 0xFFFFFFF7
;
OR_VAL: 0xC0012600 0x00000008
;
DELAY: 0x00000001	;	delay 1us
;
; 6. Read the content of OTP 32-bits at a time
;    from register OTP_RPORT_NB (RD0012604h [31:0])
;
LOAD_SM_ADDR: SM0 0xC0012604
DELAY: 0x00000001
LOAD_SM_ADDR: SM1 0xC0012604
DELAY: 0x00000001
LOAD_SM_ADDR: SM2 0xC0012604
;
; read SVC_REV in OTP Data[11:8] = (D0>>8 & 0xF)
MOV_SM_SM: SM3 SM0
RSHIFT_SM_VAL: SM3 8
AND_SM_VAL: SM3 0xF
;
; print the SVC_REV in SM3
WRITE: 0xC0012004 0x53				; Print 'S'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x56				; Print 'V'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x43				; Print 'C'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x5F				; Print '_'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x52				; Print 'R'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x45				; Print 'E'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x56				; Print 'V'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x3A				; Print ':'
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;
MOV_SM_SM: SM5 SM3
ADD_SM_VAL: SM5 0x00000030	; ASCII of '0' is 0x30
TEST_SM_AND_BRANCH: SM5 0x0000000F 0x0000000A < PTN0
ADD_SM_VAL: SM5 0x00000007	; ASCII of 'A' is 0x41
LABEL: PTN0
STORE_SM_ADDR: SM5 0xC0012004		; Print <value>
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;
WRITE: 0xC0012004 0x0D			; Print CR
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
WRITE: 0xC0012004 0x0A			; Print LF
WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>;
;<DEBUG-INFO>; print the value of SM0~SM2
;<DEBUG-INFO>WRITE: 0xC0012004 0x53				; Print 'S'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x56				; Print 'V'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x43				; Print 'C'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x5F				; Print '_'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x56				; Print 'V'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x41				; Print 'A'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x4C				; Print 'L'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x3A				; Print ':'
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>;
;<DEBUG-INFO>MOV_SM_SM: SM5 SM0
;<DEBUG-INFO>BRANCH: PRIT
;<DEBUG-INFO>LOAD_SM_VAL: SM6 0
;<DEBUG-INFO>LABEL: PTR
;<DEBUG-INFO>TEST_SM_AND_BRANCH: SM6 0x0000000F 0x00000000 == PT0
;<DEBUG-INFO>TEST_SM_AND_BRANCH: SM6 0x0000000F 0x00000001 == PT1
;<DEBUG-INFO>TEST_SM_AND_BRANCH: SM6 0x0000000F 0x00000002 == PT2
;<DEBUG-INFO>LABEL: PT0
;<DEBUG-INFO>LOAD_SM_VAL: SM6 1
;<DEBUG-INFO>MOV_SM_SM: SM5 SM1
;<DEBUG-INFO>BRANCH: PRIT
;<DEBUG-INFO>LABEL: PT1
;<DEBUG-INFO>LOAD_SM_VAL: SM6 2
;<DEBUG-INFO>MOV_SM_SM: SM5 SM2
;<DEBUG-INFO>BRANCH: PRIT
;<DEBUG-INFO>LABEL: PT2
;<DEBUG-INFO>BRANCH: PEND
;<DEBUG-INFO>;
;<DEBUG-INFO>;************************************************
;<DEBUG-INFO>; print 32bit value from MSB->LSB
;<DEBUG-INFO>; SM4: round, 8 rounds for 32 bits
;<DEBUG-INFO>; SM5: value to print
;<DEBUG-INFO>;************************************************
;<DEBUG-INFO>LABEL: PRIT
;<DEBUG-INFO>LOAD_SM_VAL: SM4 8
;<DEBUG-INFO>WRITE: 0xC0012004 0x0D			; Print CR
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>WRITE: 0xC0012004 0x0A			; Print LF
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>;
;<DEBUG-INFO>LABEL: PTN
;<DEBUG-INFO>TEST_SM_AND_BRANCH: SM4 0x0000000F 0x00000000 == PTR
;<DEBUG-INFO>MOV_SM_SM: SM7 SM5
;<DEBUG-INFO>AND_SM_VAL: SM7 0xF
;<DEBUG-INFO>; Convert to ASCII
;<DEBUG-INFO>ADD_SM_VAL: SM7 0x00000030	; ASCII of '0' is 0x30
;<DEBUG-INFO>TEST_SM_AND_BRANCH: SM7 0x0000000F 0x0000000A < PTN1
;<DEBUG-INFO>ADD_SM_VAL: SM7 0x00000007	; ASCII of 'A' is 0x41
;<DEBUG-INFO>LABEL: PTN1
;<DEBUG-INFO>STORE_SM_ADDR: SM7 0xC0012004		; Print <value>
;<DEBUG-INFO>WAIT_FOR_BIT_SET: 0xC001200C 0x20 1	; Wait for TX ready
;<DEBUG-INFO>RSHIFT_SM_VAL: SM5 4
;<DEBUG-INFO>SUB_SM_VAL: SM4 0x00000001
;<DEBUG-INFO>BRANCH: PTN
;<DEBUG-INFO>;
;<DEBUG-INFO>LABEL: PEND
